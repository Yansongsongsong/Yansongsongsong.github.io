<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />











  <meta name="baidu-site-verification" content="OzvUOmmlof" />
  <meta name="google-site-verification" content="C3yv5IlTnSiSryEG0E-cVtbm6cmw1yglbuOhEpVUCuE" />






  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/ico.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/ico.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/ico.png?v=5.1.4">


  <link rel="mask-icon" href="/images/ico.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Paxos, 分布式一致性, Paxos Made Simple" />





  <link rel="alternate" href="/atom.xml" title="One Song" type="application/atom+xml" />






<meta name="description" content="2017-2018 秋季学期，阅读论文一篇。 从 Paxos Made Simple 论文原文的角度，简要解释了Paxos算法是什么，推导过程以及用法。 参考来源：Paxos Made Simple 中文版">
<meta name="keywords" content="Paxos, 分布式一致性, Paxos Made Simple">
<meta property="og:type" content="article">
<meta property="og:title" content="paxos">
<meta property="og:url" content="https://yansongsongsong.github.io/paxos/index.html">
<meta property="og:site_name" content="One Song">
<meta property="og:description" content="2017-2018 秋季学期，阅读论文一篇。 从 Paxos Made Simple 论文原文的角度，简要解释了Paxos算法是什么，推导过程以及用法。 参考来源：Paxos Made Simple 中文版">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrkiwxnj20af0afjro">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrkxhkkj20af0afwer">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrlc7fdj20af0afjrp">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrm2awij20af0afmxf">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrn1uirj20af0afglv">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrmffzaj20af0afdg1">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrnc4chj20af0af3yp">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrnn0tfj20af0afmxe">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrnvxs3j20af0aft8y">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrp26t3j20af0af0sy">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtroruhej20af0af74j">
<meta property="og:updated_time" content="2018-01-31T20:28:00.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="paxos">
<meta name="twitter:description" content="2017-2018 秋季学期，阅读论文一篇。 从 Paxos Made Simple 论文原文的角度，简要解释了Paxos算法是什么，推导过程以及用法。 参考来源：Paxos Made Simple 中文版">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrkiwxnj20af0afjro">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yansongsongsong.github.io/paxos/"/>





  <title>paxos | One Song</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">One Song</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">one place to verbose</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yansongsongsong.github.io/paxos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="One Song">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">paxos</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-01T03:18:46+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/论文/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/论文/paxos/" itemprop="url" rel="index">
                    <span itemprop="name">paxos</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/paxos/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="paxos/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>2017-2018 秋季学期，阅读论文一篇。</p>
<p>从 Paxos Made Simple 论文原文的角度，简要解释了Paxos算法是什么，推导过程以及用法。</p>
<p>参考来源：<a href="http://dsdoc.net/paxosmadesimple/index.html" target="_blank" rel="noopener">Paxos Made Simple 中文版</a></p>
</blockquote>
<a id="more"></a>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1. 概述</h2>
<h3 id="11-问题背景"><a class="markdownIt-Anchor" href="#11-问题背景"></a> 1.1 问题背景</h3>
<p><strong>分布式系统</strong>是一组<strong>电脑</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">computer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">m</span><span class="mord mathit">p</span><span class="mord mathit">u</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>)，通过<strong>网络</strong>相互链接<strong>传递消息</strong>与通信后并协调它们的行为而形成的系统。组件之间彼此进行交互以实现一个共同的目标。把需要进行大量计算的工程数据分区成小块，由<strong>多台</strong>计算机分别计算，再上传运算结果后，将结果统一合并得出数据结论的科学。分布式系统的例子来自有所不同的<strong>面向服务的架构</strong>，<strong>大型多人在线游戏</strong>，<strong>对等网络</strong>应用。</p>
<p>分布式系统中的节点通信存在两种模型：<strong>共享内存</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>h</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>m</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Shared memory</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>)和<strong>消息传递</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mi>p</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Messages passing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">p</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span>)。基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复。</p>
<p>对于这个问题，<em>莱斯利·兰伯特</em>(英语：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>e</mi><mi>s</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>L</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Leslie Lamport</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">L</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span></span></span></span>)于1990年提出了一种<strong>基于消息传递</strong>且具有<strong>高度容错</strong>特性的<strong>一致性</strong>算法，<strong>Paxos算法</strong>。</p>
<h3 id="12-概念摘要"><a class="markdownIt-Anchor" href="#12-概念摘要"></a> 1.2 概念摘要</h3>
<h4 id="121-一致性"><a class="markdownIt-Anchor" href="#121-一致性"></a> 1.2.1 一致性</h4>
<p>在分布式系统中，<strong>一致性</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Consistency</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>，早期也叫<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>g</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Agreement</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">e</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span>)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的<strong>一致</strong>。</p>
<p><strong>一致性的定义</strong>：</p>
<ol>
<li><strong>Termination 可结束</strong>: 所有进程最终会在有限步数中结束并选取一个值, 算法不会无尽执行下去。</li>
<li><strong>Agreement 同共识</strong>: 所有进程必须同意同一个值。</li>
<li><strong>Validity 值合法</strong>: 最终达成一致的值必须是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">V_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.22222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">V_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.22222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>其中一个, 如果所有初始值都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">V_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.22222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>, 那么最终结果也必须是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">V_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.22222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。</li>
<li><strong>Integrity</strong> 完备性: 如果一个正确的进程决定采纳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span> 作为最终值，那么这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span> 必须是由一个正确进程提议的。</li>
</ol>
<h4 id="122-分布式中的网络模型"><a class="markdownIt-Anchor" href="#122-分布式中的网络模型"></a> 1.2.2 分布式中的网络模型</h4>
<ol>
<li>
<p><strong>同步网络</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>y</mi><mi>n</mi><mi>c</mi><mi>h</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>s</mi><mtext> </mtext><mi>n</mi><mi>e</mi><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">synchronous\ network</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mspace"> </span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>)</p>
<p>指满足以下条件的网络：</p>
<ul>
<li>所有节点的时钟漂移有上限</li>
<li>网络的传输时间有上限</li>
<li>所有节点的计算速度一样</li>
</ul>
<p>这意味着整个网络按照<em>round</em>运行，每个<em>round</em>中任何节点都要<strong>执行</strong>完本地计算并且可以完成一个任意大小消息的<strong>传输</strong>。</p>
<p>对于传输：一个发出的消息如果在一个<em>round</em>内没有到达， 那么一定是网络中断造成的,，这个消息会丢失，不会延迟到第二个<em>round</em>到达。</p>
<p>在这种模型下可以解决一些问题，比如<strong>拜占庭式故障</strong>。</p>
</li>
<li>
<p><strong>异步网络</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>s</mi><mi>y</mi><mi>n</mi><mi>c</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>s</mi><mtext> </mtext><mi>n</mi><mi>e</mi><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">asynchornous\ network</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mspace"> </span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>)</p>
<p>指满足以下条件的网络：</p>
<ul>
<li>节点的时钟漂移无上限</li>
<li>消息的传输延迟无上限</li>
<li>节点计算的速度不可预料</li>
</ul>
<p>在异步网络中，有些故障非常难解决，比如当你发给一个节点一个消息之后几秒钟都没有收到他的应答，有可能这个节点计算非常慢，但是也可能是节点crash或者网络延迟造成的, 你很难判断到底是发生了什么样的故障。</p>
</li>
</ol>
<h4 id="123-节点宕机"><a class="markdownIt-Anchor" href="#123-节点宕机"></a> 1.2.3 节点宕机</h4>
<p><strong>节点宕机</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">fail-stop</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">p</span></span></span></span>): 节点持续宕机，不会恢复。</p>
<h4 id="124-节点宕机恢复"><a class="markdownIt-Anchor" href="#124-节点宕机恢复"></a> 1.2.4 节点宕机恢复</h4>
<p><strong>节点宕机恢复</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>−</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">fail-recover</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>): 节点宕机一段时间后恢复。</p>
<h4 id="125-网络分化"><a class="markdownIt-Anchor" href="#125-网络分化"></a> 1.2.5 网络分化</h4>
<p><strong>网络分化</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>e</mi><mi>t</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>k</mi><mtext> </mtext><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">network\ partition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mspace"> </span><span class="mord mathit">p</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span></span></span></span>): 网络链路出现问题，将N个节点隔离成多个部分。</p>
<h4 id="126-拜占庭将军问题"><a class="markdownIt-Anchor" href="#126-拜占庭将军问题"></a> 1.2.6 拜占庭将军问题</h4>
<p><strong>拜占庭将军问题</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>y</mi><mi>a</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi><mtext> </mtext><mi>f</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>u</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">byantine\ failure</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mspace"> </span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span></span></span></span>): 在<strong>分布式计算</strong>中，不同的<strong>计算机</strong>通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的<strong>成员计算机</strong>可能出错而<em>发送错误的信息</em>，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。</p>
<h2 id="2-一致性算法"><a class="markdownIt-Anchor" href="#2-一致性算法"></a> 2. 一致性算法</h2>
<h3 id="21-问题提出"><a class="markdownIt-Anchor" href="#21-问题提出"></a> 2.1 问题提出</h3>
<p>假设有一组可以<em>提出提案</em>的<strong>进程集合</strong>。寻找一个算法使得最终有一个提案会被选定，当提案被选定后，进程最终也能获取到被选定的提案。</p>
<p>这个 <em>一致性算法</em> 需要保证：</p>
<ul>
<li><strong>唯一值</strong>：在这些被提出的<em>提案</em>中，只有<strong>一个</strong>会被选定</li>
<li><strong>值正确</strong>：如果，<strong>没有</strong>提案被提出，那么就<strong>不会有</strong>被选定的提案</li>
<li><strong>可行性</strong>：当一个提案<strong>被选定后</strong>，进程应该可以<strong>获取</strong>被选定的<em>提案信息</em>。</li>
</ul>
<h3 id="22-问题分析"><a class="markdownIt-Anchor" href="#22-问题分析"></a> 2.2 问题分析</h3>
<h4 id="221-问题重述"><a class="markdownIt-Anchor" href="#221-问题重述"></a> 2.2.1 问题重述</h4>
<p>为了便于理解，我们将提出一个等价的问题，即：</p>
<p>有一组程序<strong>进程</strong>，进程内各自维护一个变量(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span>)，目标是，提出一种算法，使得：</p>
<ol>
<li>最终只产生一个确定的值(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>)</li>
<li>当这个值(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>)被确定后，所有进程最终会将(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span>)设置为值(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>)。</li>
</ol>
<h4 id="222-解决算法"><a class="markdownIt-Anchor" href="#222-解决算法"></a> 2.2.2 解决算法</h4>
<p>对于这个问题，<em>莱斯利·兰伯特</em> 提出了<strong>Paxos算法</strong>。算法描述如下：</p>
<ul>
<li>
<p>角色</p>
<p>在该一致性算法中，有三种参与角色，我们用 <em>Proposers</em> ， <em>Acceptors</em> 和 <em>Learners</em> 来表示。一个进程可能充当不止一种角色。</p>
</li>
<li>
<p>算法执行步骤</p>
<p><strong>Phase 1</strong></p>
<ol>
<li>
<p><em>Proposers</em> 的<strong>prepare请求</strong>：</p>
<p><em>Proposer</em> 选择一个<u>提案</u><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，然后向<em>Acceptors</em>的某个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>j</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">majority</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>集合的成员发送编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的<strong>prepare请求</strong>。</p>
</li>
<li>
<p><em>Acceptors</em> 的<strong>响应</strong>：</p>
<p>当一个<em>Acceptor</em>收到一个编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的<strong>prepare请求</strong>，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 大于它已经<strong>响应</strong>的所有<strong>prepare请求</strong>的编号，那么</p>
<ul>
<li>它就会保证不会再<strong>通过</strong>任何编号小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的<u>提案</u></li>
<li>同时将它已经通过的最大编号的<u>提案</u>(如果存在的话，即一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt; id, value&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mrel">&lt;</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mrel">&gt;</span></span></span></span>对)作为<strong>响应</strong>。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li>
</ul>
<blockquote>
<p><strong>响应</strong>动作做的最重要的两件事是</p>
<ol>
<li>提出一个不会<strong>通过</strong>任何编号小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的<u>提案</u>。</li>
<li>给发来<strong>prepare请求</strong>的<em>Proposers</em> 一个反馈，使算法进入<strong>Phase 2</strong></li>
</ol>
</blockquote>
</li>
</ol>
<p><strong>Phase 2</strong></p>
<ol>
<li>
<p><em>Proposers</em> 的<strong>accept请求</strong>：</p>
<p>如果<em>Proposer</em>收到来自半数以上的<em>Acceptor</em>对于它的<strong>prepare请求</strong>(编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> )的<strong>响应</strong>，那么它就会发送一个编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span> 的<u>提案</u>的<strong>accept请求</strong>给<em>Acceptors</em>。</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span> 的确定，遵循：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span> 是收到的<strong>响应</strong>中编号最大的<u>提案</u>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值。</li>
<li>如果响应中不包含<u>提案</u><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，那么它就是由<em>Proposer</em>指定的任意值。</li>
</ul>
</li>
<li>
<p><em>Acceptors</em> 的<strong>通过</strong>：</p>
<p>如果<em>Acceptor</em>收到一个针对编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的<u>提案</u>的<strong>accept请求</strong>，只要它还未对编号大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的<strong>prepare请求</strong>作出<strong>响应</strong>，它就可以<strong>通过</strong>这个<u>提案</u>。</p>
</li>
</ol>
<p><strong>Phase 3</strong></p>
<p>每个<em>Acceptor</em>，只要它通过了一个<u>提案</u>，就通知所有的<em>Learners</em>，将它通过的<u>提案</u>告知它们。最终由<em>Learners</em>决定哪个值为最终一致的值。</p>
</li>
</ul>
<p>至此，完整的<strong>Paxos算法</strong>已经介绍完毕</p>
<h3 id="23-算法分析"><a class="markdownIt-Anchor" href="#23-算法分析"></a> 2.3 算法分析</h3>
<p>下面讲述算法是如何推导出来的，以及算法的证明。</p>
<h4 id="231-相关概念"><a class="markdownIt-Anchor" href="#231-相关概念"></a> 2.3.1 相关概念</h4>
<p>根据[问题提出](#2.1 问题提出)，对于一致性来说，<strong>安全性</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>f</mi><mi>e</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Safety</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>)需求就是这样的：</p>
<ol>
<li>只有被提出的提案才能被选定。</li>
<li>只能有一个值被选定(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">chosen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">n</span></span></span></span>)。</li>
<li>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个。</li>
</ol>
<p>我们不会精确地描述<strong>活性(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Liveness</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span></span></span></span>)</strong><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>需求。整体上来说，目标就是：</p>
<ol>
<li>要保证最终有一个提案会被选定</li>
<li>当提案被选定后，进程最终也能获取到被选定的提案。</li>
</ol>
<blockquote>
<p>什么是<strong>活性</strong>，什么是<strong>安全性</strong>呢？</p>
<p><strong>活性</strong>和<strong>安全性</strong>都是对系统<strong>正确性</strong>的能力的描述。</p>
<p><strong>安全性</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>a</mi><mi>f</mi><mi>e</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Safety</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>)指的是，你所构建的这个系统，应当能保证坏的事情不发生。</p>
<p>比如，如果车钥匙扭到点火的位置，车子必须启动；<code>.exe</code>程序打开，就一定要能够运行；钟表能够滴答。等等</p>
<p><strong>活性</strong>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Liveness</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">L</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span></span></span></span>)指的是，你所构建的这个系统，应当能保证好的事情会发生。</p>
<p>红灯最终会变绿。如果车钥匙扭到点火的位置，车子最终将会启动。程序最终将会终止。钟表会无限滴答。等等</p>
<p>根据FLP定律，异步通信的场景下，没有一个算法可以同时做到绝对的<strong>活性</strong>和<strong>安全性</strong>。</p>
</blockquote>
<p>假设不同参与者之间可以通过发送消息来通信，我们使用普通的非拜占庭模式的<strong>异步</strong>模型<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup>：</p>
<ul>
<li>每个参与者以<strong>任意的速度</strong>执行，可能会出错而停止，也可能会重启。当一个提案被选定后，所有的参与者都有可能失败或重启，因此除非那些失败或重启的参与者可以记录某些信息，否则是不可能存在一个解的。</li>
<li>消息在传输中可能花费任意的时间，可能会重复，丢失，但是不会被损坏。<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup></li>
</ul>
<blockquote>
<p>这里遵循容错理论在分布式系统开发的应用，即：</p>
<p>我们通过构建<strong>失效停止计算机</strong>来规避实际生产中，可能出现的拜占庭错误所带来的不可预知的错误，以提高分布式系统的容错性。</p>
</blockquote>
<h4 id="232-提案的选定"><a class="markdownIt-Anchor" href="#232-提案的选定"></a> 2.3.2 提案的选定</h4>
<blockquote>
<p>2.3.2 论述了如何选定一个提案，来达到想要得出的这个算法的[<strong>唯一值</strong>](#2.1 问题提出)的特性。</p>
</blockquote>
<h5 id="2321-最简单的提案方法"><a class="markdownIt-Anchor" href="#2321-最简单的提案方法"></a> 2.3.2.1 最简单的提案方法</h5>
<p>只允许一个<em>Accpetor</em>存在。<em>Proposer</em>发送提案给<em>Accpetor</em>，<em>Acceptor</em>会选择它接收到的第一个提案作为被选定的提案。</p>
<p><strong>缺点：<strong>如果<em>Accpetor</em>出错，那么整个系统就无法工作了。即存在</strong>单点故障</strong>。</p>
<h5 id="2322-多accpetor提案方法"><a class="markdownIt-Anchor" href="#2322-多accpetor提案方法"></a> 2.3.2.2 多<em>Accpetor</em>提案方法</h5>
<p>现在，<em>Proposer</em>向一个<em>Acceptor</em>集合发送<u>提案</u>，某个<em>Acceptor</em>可能会<strong>通过</strong>这个<u>提案</u>。当有足够多的<em>Acceptor</em> <strong>通过</strong>它的时候，我们就可以认为这个<u>提案</u>被选定了。</p>
<blockquote>
<p>什么是***足够多***呢？</p>
<p>为了能确保只有<strong>一个</strong><u>提案</u>被选定，我们可以让这个集合大的可以包含<em>Acceptor</em>集合中的<strong>多数成员</strong>。</p>
<p>因为任何两个多数集*<em><em>至少有一个公共成员***，如果我们再规定一个</em>Acceptor</em>最多只能通过一个<u>提案</u>，那么就能保证只有一个提案被选定(这是对于很多论文都研究过的majority的一个简单的应用 <sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup> )</p>
</blockquote>
<p>在没有失败和消息丢失的情况下，如果我们希望即使在只有一个<u>提案</u>被提出的情况下，仍然可以选出一个<u>提案</u>来（即要满足[活性](#2.3.1 相关概念)之一），就一定会满足需求：</p>
P1.\ 一个Acceptor必须通过它收到的第一个提案。

<p>我们自然可以联想到，如果有5个<em>Acceptor</em>，其中2个通过了<u>提案</u> a ，另外3个通过了<u>提案</u> b ，此时如果通过 b 的3个中有一个出错了，那么 a 、 b 的通过者都变成了2个，这不清楚该如何决定了。</p>
<p>这自然不是我们要的。那么在 a 、 b 的通过者都变成了2个，这不清楚该如何决定时，我们还需要继续提出<strong>提案</strong>，让<em>Acceptors</em>接受，这就说明，一个<em>Acceptor</em>必须能够<strong>通过</strong>不止一个提案。所以我们需要为每个<u>提案</u>设定一个唯一的编号来记录一个<em>Acceptor</em>通过的那些<u>提案</u>。</p>
<p>当一个具有某<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值的提案被半数以上的<em>Acceptor</em>通过后，我们就认为该<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>被<strong>选定</strong>了。此时我们也认为该<u>提案</u><sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup>被选定了。</p>
<p>既然我们允许多个<u>提案</u>被选定，那么我们必须要保证所有被选定的<u>提案</u>都具有相同的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值。在<u>提案</u>编号上规约，它需要保证：</p>
P2. \ 如果具有value值v的提案被选定(chosen)了，\\那么所有比它编号更高的被选定的提案的value值也必须是 v 。

<blockquote>
<p>因为编号是全序的，条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">P2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathrm">2</span></span></span></span> 就保证了<strong>只有一个</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值被选定的这一关键[<strong>安全性</strong>](#2.3.1 相关概念)属性(<strong>安全性之二)</strong>。</p>
</blockquote>
<p>那个被选定的<u>提案</u>，首先必须被至少一个<em>Acceptor</em>通过，因此我们可以通过满足如下条件来满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">P2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathrm">2</span></span></span></span> ：</p>
P2^a. \ 如果具有value值 v 的提案被选定(chosen)了，\\ 那么所有比它编号更高的被Acceptor通过的提案的value值也必须是 v 。

<blockquote>
<p>比如有<em>Acceptor</em>  <em>A1</em>，经过一些步骤后，选定了&lt; id = 3, value = 100 &gt;的提案，那么由上论述，仍然有情况，使<em>A1</em>需要继续通过id更高（因为提案生成的更晚，虽然提案审核的顺序和天生成的顺序没有直接关联）的提案。</p>
<p>所以对于<em>A1</em>后来通过的，那些id更高的提案，它们的value必须等于100，才满足<strong>安全性之二</strong>的要求。所以才有了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">P2^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的需求。</p>
</blockquote>
<p>我们仍然需要$ P1$ 来保证<u>提案</u>会被<strong>选定</strong>(满足<strong>活性</strong>)。</p>
<p>但是因为通信是异步的，一个<u>提案</u>可能会在某个<em>Acceptor</em> c 还未收到任何提案时就被<strong>选定</strong>了，我们可以假设<u>提案</u>为 **&lt; id = 1, value = a&gt; <strong>) 。这时一个新的<em>Proposer</em>产生了一个具有另一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值的更高编号的提案，我们假设为</strong>&lt; id = 4, value = b&gt; **。</p>
<p>根据 $ P1$ ，就需要<em>Acceptor</em> c 通过这个<u>提案</u>（**&lt; id = 4, value = b&gt; **），但是这与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">P2^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 矛盾（value 应该为 被选中的提案 a）。因此如果要同时满足 $ P1$ 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">P2^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，需要对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">P2^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>进行强化：</p>
P2^b. \ 如果具有value值v的提案被选定，\\ 那么所有比它编号更高的被Proposer提出的提案的value值也必须是 v 。

<blockquote>
<p>一个提案被<em>Acceptor</em>通过之前肯定要由某个<em>Proposer</em>提出，因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">P2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.849108em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">b</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 就隐含了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">P2^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> ，进而隐含了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">P2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathrm">2</span></span></span></span> 。</p>
<p>为了发现如何保证 P2b ，我们来看看如何证明它成立。</p>
</blockquote>
<p>我们假设某个具有&lt; id = m, value = v &gt;的<u>提案</u>被<strong>选定</strong>了，需要证明:</p>
<p>具有编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>&gt;</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n(n &gt; m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mrel">&gt;</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span> 的提案都具有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span></span></span></span> 。</p>
<blockquote>
<p>我们可以通过对 n 使用归纳法来简化证明，这样我们就可以在额外的假设下——</p>
<p>即编号在 m…(n-1) 之间的提案具有value值 v ，来证明编号为n的提案具有value值 v 。</p>
<p>因为编号为m的提案已经被选定了，这意味着肯定存在一个由半数以上的Acceptor组成的集合 C， C 中的每个Acceptor都通过了这个提案。再结合归纳假设， m 被选定意味着：</p>
<p><em><u>C 中的每个Acceptor都通过了一个编号在 m…n-1 之间的提案，每个编号在 m…(n-1) 之间的被Acceptor通过的提案都具有value值 v。</u></em></p>
<p>因为任何包含半数以上的Acceptor的集合S都至少包含 C 中的一个成员，我们可以通过维护如下不变性就可以保证编号为n的提案具有value v：</p>
</blockquote>
P2^c. \ 对于任意的 n 和 v ，如果编号为 n 和value值为 v 的提案被提出，\\ 那么肯定存在一个由半数以上的Acceptor组成的集合 S ，可以满足条件 a) 或者 b) 中的一个：

\\a) \ S 中不存在任何的Acceptor通过过编号小于 n 的提案
\\b) \ v 是 S 中所有Acceptor通过的编号小于 n 的具有最大编号的提案的value值。

<p>通过维护 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>2</mn><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">P2^c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">c</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 我们就可以保证$ P2^b$ 了。</p>
<blockquote>
<p>实际上 P2c 规定了每个Proposer 如何产生一个提案，对于产生的每个提案 (n, v) 需要满足这个条件“存在一个由超过半数的Acceptor 组成的集合 S ：要么 S 中没有人批准(accept)过编号小于 n 的任何提案，要么 S 的任何Acceptor批准的所有议案（编号小于 n ）中， v 是编号最大的议案的决议”。当Proposer遵守这个规则产生提案时，就可以保证满足 P2b 。论文中，作者是从如何产生提案进而可以保证 P2b 来思考，才得到 P2c 的。下面我们反过来看，证明 P2c 可以保证 P2b 。如论文中一样，采用数学归纳法证明。</p>
<p>首先假设提案 (m, v) 被选定了，设比该提案编号大的提案为 (n, v’) ,我们需要证明的就是在 P2c 的前提下，对于所有的 (n, v’) ，有 v’ = v 。</p>
<ol>
<li>n = m + 1 时，如果有这样编号的提案，首先我们知道 (m, v) 被选定了，这样就不可能存在一个 S 且 S 中没有人批准过小于 n 的提案（ S 与批准 (m, v) 的Acceptor集合肯定有交集），那 v’ 只能是多数集 S 中编号小于 n 的最大编号的那个提案的值了，此时 n = m + 1 ，理论上小于n的最大的编号肯定是 m ，同时由于 S 和通过 (m, v) 的Acceptor集合都是多数集，就保证了二者肯定有交集，这样Proposer在确定 v’ 取值时，肯定选到就是 v 。</li>
</ol>
<p>上面实际上就是数学归纳法的第一步，确切的说是使用的是第二数学归纳法。上面是第一步，验证了某个初始值成立。下面，需要假设编号在 [m+1, k-1] 区间内成立，并在此基础上推出 n = k 上也成立。</p>
<ol>
<li>根据假设编号在 [m+1, k-1] 区间内的所有提案都具有值 v ，需要证明的是编号为k的提案也具有值 v 。根据 P2c ，首先同样的不可能存在一个 S 且 S 中没有人批准过小于 n 的提案，那么编号为 k 的value值，只能是一个多数集 S 中编号小于 n 的最大编号的那个提案的值，如果这个最大编号落在 [m+1, k-1] 区间内的，那么值肯定是 v ，如果不是落在 [m+1, k-1] 区间，那么它的编号肯定就是 m 了，不可能比 m 再小了，因为 S 也肯定会与批准 (m, v) 的Acceptor集合肯定有交集，那么它的编号值就不会比 m 小，而编号如果是 m 那么它的值也是 v 。由此得证。</li>
</ol>
</blockquote>
<p>为了维护$ P2^c$ 的不变性，一个<em>Proposer</em>在产生编号为 n 的提案时，必须要知道某一个<strong>将要</strong>或<strong>已经</strong>被半数以上<em>Acceptor</em>通过的编号小于 n 的最大编号的<u>提案</u>。</p>
<p>为了避免对“<strong>将要</strong>”成为被半数以上<em>Acceptor</em>通过的<u>提案</u>做预测，我们通过对<u>提案</u>生成算法的限定，来控制避免预测。即令，<em>Proposer</em>会请求<em>Acceptors</em>不要再通过任何编号小于 n 的提案。这就推导出了<em>Proposer</em>对如下的<u>提案</u>生成算法：</p>
<ol>
<li>
<p><em>Proposers</em> 的<strong>prepare请求</strong>：</p>
<p><em>Proposer</em>选择一个新的<u>提案</u>编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> ，然后向某个<em>Acceptors</em>集合的成员发送请求，要求<em>Acceptor</em>做出如下回应：</p>
<blockquote>
<ol>
<li>保证不再通过任何编号小于 n 的提案</li>
<li>当前它已经通过的编号小于 n 的最大编号的提案，如果存在的话。</li>
</ol>
<p>我们把这样的一个请求称为编号为 n 的prepare请求。</p>
</blockquote>
</li>
<li>
<p><em>Proposers</em> 的<strong>accept请求</strong>：</p>
<p>如果<em>Proposer</em>收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为 n ，value值为 v 的<u>提案</u>，这里 v 是所有响应中编号最大的提案的value值，如果响应中不包含任何的<u>提案</u>那么这个值就可以由Proposer任意选择。</p>
<p><em>Proposer</em>通过向某个<em>Acceptors</em>集合发送需要被<strong>通过</strong>的<u>提案</u>请求来产生一个提案（此时的<em>Acceptors</em>集合不一定是响应前一请求的那个<em>Acceptors</em>集合）。我们称此请求为 <strong>accept 请求</strong>。</p>
</li>
</ol>
<p>目前我们描述了<em>Proposer</em>端的算法，<em>Acceptor</em>端是怎样的呢？</p>
<p>它可能会收到来自<em>Proposer</em>端的两种请求：<strong>prepare请求</strong>和<strong>accept请求</strong>。</p>
<p><em>Acceptor</em>可以忽略任何请求而不用担心破坏其算法的<strong>安全性</strong>。</p>
<p>因此我们只需要说明它在什么情况下可以对一个请求做出响应。它可以在任何时候响应一个<strong>prepare请求</strong>，对于一个<strong>accept请求</strong>，只要在它未违反现有承诺的情况下才能响应一个<strong>accept请求</strong>(通过对应的<u>提案</u>)。换句话说：</p>
P1^a. \ 一个Acceptor可以接受一个编号为 n 的提案，\\只要它还未响应任何编号大于 n 的prepare请求。

<p>可以看出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msup><mn>1</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">P1^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathrm">1</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">a</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 蕴含了$ P1 $。</p>
<p>我们现在就获得一个满足<strong>安全性</strong>需求的提案选定算法——假设编号唯一的情况下。再做一些小的优化就得到了最终的算法。</p>
<blockquote>
<p>假设一个<em>Acceptor</em>收到了一个编号为 n 的<strong>prepare请求</strong>，但是它已经对编号大于 n 的prepare请求做出了响应，因此它肯定不会再通过任何新的编号为n的提案，那么它就没有必要对这个请求做出响应，因为它肯定不会通过编号为 n 的提案，因此我们会让<em>Acceptor</em>忽略这样的<strong>prepare请求</strong>。我们也会让它忽略那些它已经通过的提案的<strong>prepare请求</strong>。</p>
<p>通过这个优化，<em>Acceptor</em>只需要记住它已经通过的最大编号的提案以及它已经做出<strong>prepare请求</strong>响应的最大编号的提案的编号。因为必须要保证 P1c 的不变性即使在出错的情况下，<em>Acceptor</em>必须记住这些信息即使是在出错或者重启的情况下。<em>Proposer</em>可以总是可以丢弃提案以及它所有的信息—只要它可以保证不会产生具有相同编号的提案即可。</p>
</blockquote>
<p>将<em>Proposer</em>和<em>Acceptor</em>放在一块，我们可以得到算法的两阶段执行过程，即[解决算法](#2.2.2 解决算法)。</p>
<h2 id="3-获取被选定的提案值"><a class="markdownIt-Anchor" href="#3-获取被选定的提案值"></a> 3. 获取被选定的提案值</h2>
<p>为了获取被<strong>选定</strong>的值，一个<em>Learner</em>必须确定一个<u>提案</u>已经被半数以上的<em>Acceptor</em>通过。</p>
<ol>
<li>
<p>最明显的算法是，让每个<em>Acceptor</em>，只要它通过了一个<u>提案</u>，就通知所有的<em>Learners</em>，将它通过的<u>提案</u>告知它们。这可以让<em>Learners</em>尽快的找出被选定的值，但是它需要每个<em>Acceptor</em>都要与每个<em>Learner</em>通信—所需通信的次数等于二者个数的乘积。</p>
</li>
<li>
<p>另外一个算法，我们可以让所有的<em>Acceptor</em>将它们的通过信息发送给一个特定的<em>Learner</em>，当一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>被选定时，再由它通知其他的<em>Learners</em>。这种方法，需要多一个步骤才能通知到所有的<em>Learners</em>。而且也是不可靠的，因为那个特定的<em>Learner</em>可能会失败。但是这种情况下的通信次数，只是<em>Acceptors</em>和<em>Learners</em>的个数的和。</p>
<p>更一般的，Acceptors可以将它们的通过信息发送给一个特定的Learners集合，它们中的每个都可以在一个value被选定后通知所有的Learners。这个集合中的Learners个数越多，可靠性就越好，但是通信复杂度就越高。</p>
</li>
</ol>
<p>由于消息的丢失，一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>被选定后，可能没有<em>Learners</em>会发现。<em>Learner</em>可以询问<em>Acceptors</em>它们通过了哪些<u>提案</u>，但是一个<em>Acceptor</em>出错，都有可能导致无法判断出是否已经有半数以上的<em>Acceptors</em>通过的<u>提案</u>。</p>
<p>在这种情况下，只有当一个新的<u>提案</u>被<strong>选定</strong>时，<em>Learners</em>才能发现被<strong>选定</strong>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>。因此如果一个<em>Learner</em>想知道是否已经<strong>选定</strong>一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span>，它可以让<em>Proposer</em>利用上面的算法产生一个<u>提案</u>。</p>
<h2 id="4-进展性"><a class="markdownIt-Anchor" href="#4-进展性"></a> 4. 进展性</h2>
<h3 id="41-flp-impossibility"><a class="markdownIt-Anchor" href="#41-flp-impossibility"></a> 4.1 FLP impossibility</h3>
<p>分布式系统一致性协议里面有一个FLP impossibility的结论，这个结论是说，在分布式系统中，<strong>异步网络</strong>（消息延迟可能任意大或丢失，消息可能乱序），只要有一个进程失效（进程死亡或者足够长时间不响应），就不可能设计出一个一致性协议。</p>
<p>这个结论说明了，即使有一个协议能满足分布式下的容错条件，也无法达成分布式下的一致性；只要存在进程失效的情况，就不存在可以达成一致性的协议。</p>
<h3 id="41-活锁"><a class="markdownIt-Anchor" href="#41-活锁"></a> 4.1 活锁</h3>
<p>很容易构造出一种情况，在该情况下，两个<em>Proposers</em>持续地生成编号递增的一系列提案，但是没有提案会被选定。</p>
<ol>
<li><em>Proposer</em> p1 为一个编号为 n1 的提案完成了<strong>Phase1</strong>，然后另一个<em>Proposer</em> q 为编号为 n2(n2 &gt; n1) 的提案完成了<strong>Phase1</strong>。</li>
<li><em>Proposer</em> p 的针对编号 n1 的提案的<strong>Phase2</strong>的所有<strong>accept请求</strong>被忽略，因为<em>Acceptors</em>已经承诺不再通过任何编号小于 n2 的提案。</li>
<li>这样<em>Proposer</em> p 就会用一个新的编号 n3(n3 &gt; n2) 重新开始并完成<strong>Phase1</strong>，这又会导致在<strong>Phase2</strong>里<em>Proposer</em> q 的所有<strong>accept请求</strong>被忽略，如此循环往复。</li>
</ol>
<p>这种情况下算法产生<strong>活锁</strong>。</p>
<h3 id="42-leader算法"><a class="markdownIt-Anchor" href="#42-leader算法"></a> 4.2 Leader算法</h3>
<h4 id="421-概述"><a class="markdownIt-Anchor" href="#421-概述"></a> 4.2.1 概述</h4>
<p>为了解决<strong>活锁</strong>，我们选择一个特定的<em>Proposer</em>来作为一个唯一的<u>提案</u>提出者。如果这个<em>Proposer</em>可以同半数以上的<em>Acceptors</em>通信，那么它就可以获知目前编号信息，继而可以</p>
<ol>
<li>使用一个比现有的编号都大的编号，成功的产生一个可以被通过的提案。</li>
<li>知道某些更高编号的请求时，舍弃当前的提案并重做，产生一个足够大的提案编号继而成功的产生一个可以被通过的提案</li>
</ol>
<p>那么如果系统中有足够的组件(<em>Proposer</em>，<em>Acceptors</em>及通信网络)工作良好，通过选择一个特定的<em>Proposer</em>，<strong>活性</strong>就可以达到。</p>
<p>对于Leader的选举，我们可以利用<strong>随机性</strong>或者利用<strong>实时性</strong>（比如使用超时机制）来实现一个可靠的<em>Proposer</em>选举算法。</p>
<blockquote>
<p>然而，无论选举是否成功，安全性都可以保证，因为经过上述论证，即使同时有2个或以上的<em>Proposers</em>存在，算法仍然可以保证正确性。</p>
</blockquote>
<h4 id="422-multi-paxos"><a class="markdownIt-Anchor" href="#422-multi-paxos"></a> 4.2.2 Multi-Paxos</h4>
<h5 id="4221-算法描述"><a class="markdownIt-Anchor" href="#4221-算法描述"></a> 4.2.2.1 算法描述</h5>
<p>使用了<em>Leader</em>算法的Paxos算法，被称作Multi-Paxos算法。</p>
<p>在Paxos集群中利用Paxos协议选举唯一的leader，在leader有效期内所有的议案都只能由leader发起，这里强化了协议的假设：即leader有效期内不会有其他server提出的议案。</p>
<p>Multi-Paxos可以简单的理解为，经过一轮的Basic-Paxos，成功得到多数派<strong>accept</strong>的<em>proposer</em>即成为leader（这个过程称为leader Elect），之后可以通过lease机制，保持这个leader的身份，使得其他<em>proposer</em>不再发起提案，这样就进入了一个leader任期。在leader任期中，由于没有了并发冲突，这个leader在对后续的日志进行投票时，不必每次都向多数派询问logID，也不必执行<strong>prepare</strong>阶段，直接执行<strong>accept</strong>阶段即可。</p>
<h5 id="4222-幽灵复现缺陷"><a class="markdownIt-Anchor" href="#4222-幽灵复现缺陷"></a> 4.2.2.2 幽灵复现缺陷</h5>
<p>使用Paxos协议处理日志的备份与恢复，可以保证确认形成多数派的日志不丢失，但是无法避免一种被称为“幽灵复现”的现象，这里不再赘述</p>
<h2 id="5-paxos实例"><a class="markdownIt-Anchor" href="#5-paxos实例"></a> 5. Paxos实例</h2>
<h3 id="51-朴素paxos实例"><a class="markdownIt-Anchor" href="#51-朴素paxos实例"></a> 5.1 朴素Paxos实例</h3>
<h4 id="512-实例描述"><a class="markdownIt-Anchor" href="#512-实例描述"></a> 5.1.2 实例描述</h4>
<p>我们假设目前有共有7台主机，7台主机均为<em>Learner</em>，其中5台为<em>Acceptor</em>，2台为<em>Proposer</em>，如图所示。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrkiwxnj20af0afjro" alt=""></p>
<p>第一阶段，P1向A1 - A3发送<strong>Prepare请求</strong>，编号id为2。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrkxhkkj20af0afwer" alt=""></p>
<p>第二阶段，A1 - A3 检查自己的Rid，发现可以<strong>响应</strong>，给P1发送响应信息。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrlc7fdj20af0afjrp" alt=""></p>
<p>第三阶段，P1接收到三个人的响应，满足多数派原则，开始向A1 - A3发送<strong>Accept请求</strong>，提案编号为2，值为任意生成的a，提案即&lt; id = 2, value =a&gt;，但由于网络原因，发给A2、A3的请求陷入延迟。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrm2awij20af0afmxf" alt=""></p>
<p>第四阶段，P2向A1 - A3发送<strong>Prepare请求</strong>，编号id为1。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrn1uirj20af0afglv" alt=""></p>
<p>第五阶段，A1 - A3 检查自己的Rid，此时它们<strong>响应</strong>过的最大的<strong>Prepare请求</strong>id为2，即Rid的值为2，大于P2的编号id为1的<strong>Prepare请求</strong>，<em>Acceptors</em>选择拒绝响应，并返回自己响应的最大的id值，帮助P2修改<strong>Prepare请求</strong>id值。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrmffzaj20af0afdg1" alt=""></p>
<p>第六阶段，P2检查到得到的值，生成了一个更大的id值，然后向A2- A3发送<strong>Prepare请求</strong>，编号id为3。仍满足多数派原则。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrnc4chj20af0af3yp" alt=""></p>
<p>第七阶段，A2、 A3 检查自己的Rid，发现可以<strong>响应</strong>，给P2发送响应信息。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrnn0tfj20af0afmxe" alt=""></p>
<p>第八阶段，P2接收到两个人的响应，满足多数派原则，开始向A2 、 A3发送<strong>Accept请求</strong>，提案即&lt; id = 3, value =b&gt;。A2 、 A3通过该提案。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrnvxs3j20af0aft8y" alt=""></p>
<p>第九阶段，P1的<strong>Acept请求</strong>经过网络延迟最终到达A2、A3。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtrp26t3j20af0af0sy" alt=""></p>
<p>第十阶段，A2、A3检查自己的Rid，与<strong>Acept请求</strong>请求不符，所以拒绝了P1的<strong>Acept请求</strong>。</p>
<p><img src="https://ws1.sinaimg.cn/large/702606f7ly1fnbtroruhej20af0af74j" alt=""></p>
<p>第十一阶段，确定值了的A1 - A3，将自己选定的值发给<em>Learner</em>，<em>Learner</em>根据返回情况决定出一致结果，即value = b。</p>
<h4 id="513-宕机情况"><a class="markdownIt-Anchor" href="#513-宕机情况"></a> 5.1.3 宕机情况</h4>
<p>现在让我们来设想一个情况，在第十一阶段时，A2宕机，L1的统计结果为value a : b = 1 : 1，没有多数派的出现，这种情况应该怎么办呢？</p>
<p>解决方案是，让P1重新发起一次<u>提案</u>。我们可以看到</p>
<ol>
<li>如果A2在P1发起<u>提案</u>后，不再宕机，根据算法，P1发起的<strong>Accept请求</strong>的value值必为A1 - A3的多数派value = b，L1也就可以得到多数派值 b。</li>
<li>如果A2保持宕机，P1 就无法发起提案，因为在<strong>Prepare请求</strong>阶段，不能达到多数派的响应，所以也没办法保证发起新的<u>提案</u>（即没有办法改值），但值得注意的是，尽管这样，我们仍保证了一致值没有被修改，仍是b。这一点说明了Paxos算法的安全性。</li>
</ol>
<h2 id="6-拓展"><a class="markdownIt-Anchor" href="#6-拓展"></a> 6. 拓展</h2>
<p>分布式一致性协议，除了Paxos协议之外，还有：</p>
<ol>
<li>Raft协议</li>
<li>Zab协议</li>
<li>Quorom机制</li>
</ol>
<h3 id="61-raft协议"><a class="markdownIt-Anchor" href="#61-raft协议"></a> 6.1 Raft协议</h3>
<p><strong>Raft</strong>是一个共识算法，取代Paxos。Raft的目标是提供更好理解的算法，并且证明可以提供与Paxos相同的容错性以及性能</p>
<p>Raft透过选举<strong>领袖</strong>（英语：leader）的方式实做共识算法。</p>
<p>在Raft丛集（英语：Raft cluster）里，服务器可能会是这三种身份其中一个：<strong>领袖</strong>（英语：leader）、<strong>追随者</strong>（英语：follower），或是<strong>候选人</strong>（英语：candidate）。在正常情况下只会有一个领袖，其他都是追随者。而领袖会负责所有外部的请求，如果不是领袖的机器收到时，请求会被导到领袖。</p>
<p>通常领袖会借由固定时间发送讯息，也就是“心跳（英语：heartbeat）”，让追随者知道丛集的领袖还在运作。而每个追随者都会设计超时机制（英语：timeout），当超过一定时间没有收到心跳（通常是150 ms或300 ms），丛集就会进入选举状态。</p>
<p>Raft将问题拆成数个子问题分开解决，让人更容易了解：</p>
<ul>
<li>领袖选举（英语：Leader Election）</li>
<li>记录复写（英语：Log Replication）</li>
<li>安全性（英语：Safety）</li>
</ul>
<h3 id="62-zab协议"><a class="markdownIt-Anchor" href="#62-zab协议"></a> 6.2 Zab协议</h3>
<p>Zab 协议借鉴了 Paxos 的思想，并进行了改进，以满足工程上的实际需求。</p>
<p>Zab 协议分为两大块：</p>
<ul>
<li>广播（boardcast）：Zab 协议中，所有的写请求都由 leader 来处理。正常工作状态下，leader 接收请求并通过广播协议来处理。</li>
<li>恢复（recovery）：当服务初次启动，或者 leader 节点挂了，系统就会进入恢复模式，直到选出了有合法数量 follower 的新 leader，然后新 leader  负责将整个系统同步到最新状态。</li>
</ul>
<h3 id="63-quorom机制"><a class="markdownIt-Anchor" href="#63-quorom机制"></a> 6.3 Quorom机制</h3>
<p><strong>Quorom</strong> 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于<a href="https://zh.wikipedia.org/wiki/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">鸽巢原理</a>。</p>
<p>在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。</p>
<p>该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。</p>
<p>分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作必须获得获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>r</mi><mo>+</mo><mi>V</mi><mi>w</mi><mo>&gt;</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Vr + Vw &gt; V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mrel">&gt;</span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>w</mi><mo>&gt;</mo><mi>V</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">Vw &gt; V/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mrel">&gt;</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></li>
</ol>
<p>第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Vw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span></span>个冗余拷贝的许可。而剩下的数量是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>−</mo><mi>V</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">V-Vw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span></span> 不够<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Vr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>，因此不能再有读请求过来了。同理，当读请求已经获得了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Vr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>个冗余拷贝的许可时，写请求就无法获得许可了。</p>
<p>第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><strong>提案</strong>，本质上是一个 &lt; n, value &gt; 对，n表示编号，value 表示想要设定的值。</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><strong>编号</strong>的产生需要保证唯一性，不同的 <em>Proposers</em> 会从不相交的编号集合中选择自己的编号，这样任何两个<em>Proposers</em>就不会有相同编号的提案了。每个<em>Proposer</em>需要将它目前生成的最大编号的提案记录在可靠性存储设备中，然后用一个比已经使用的所有编号都大的提案开始<strong>Phase1</strong>。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><strong><em>marjority</em> 集合</strong>，指的是一个集合所有的子集中，集合内元素个数大于该集合半数的子集。</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">此时<em>Acceptor</em>才真正发起了一个<strong>响应</strong>。</span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">即发起<strong>响应</strong>的<em>Acceptors</em>中没有执行<strong>通过</strong>动作的。</span><a href="#fnref:5" rev="footnote"> ↩</a></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">6.</span><span style="display: inline-block; vertical-align: top;">一个分布式算法，有两个最重要的属性：Safety 和Liveness，简单来说：Safety是指那些需要保证永远都不会发生的事情。liveness是指那些最终一定会发生的事情。</span><a href="#fnref:6" rev="footnote"> ↩</a></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">7.</span><span style="display: inline-block; vertical-align: top;">异步通信意味着，这个算法无法做到强一致性。</span><a href="#fnref:7" rev="footnote"> ↩</a></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">8.</span><span style="display: inline-block; vertical-align: top;">即无拜占庭错。</span><a href="#fnref:8" rev="footnote"> ↩</a></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">9.</span><span style="display: inline-block; vertical-align: top;">Leslie Lamport. The implementation of reliable distributed multiprocess systems. Computer Networks, 2:95–114, 1978.</span><a href="#fnref:9" rev="footnote"> ↩</a></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">10.</span><span style="display: inline-block; vertical-align: top;">此时的提案已经跟value变成了不同的东西，提案是由 &lt;编号+value&gt; 组成的。注意什么叫“选定”</span><a href="#fnref:10" rev="footnote"> ↩</a></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">11.</span><span style="display: inline-block; vertical-align: top;">即2.2.2 提出的算法中对于最大编号提案的规则约束的原因</span><a href="#fnref:11" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/分布式一致性/" rel="tag"># 分布式一致性</a>
          
            <a href="/tags/paxos/" rel="tag"># paxos</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Init/" rel="next" title="Init">
                <i class="fa fa-chevron-left"></i> Init
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5a718656551a6c42" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Song</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述"><span class="nav-number">1.</span> <span class="nav-text"> 1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-问题背景"><span class="nav-number">1.1.</span> <span class="nav-text"> 1.1 问题背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-概念摘要"><span class="nav-number">1.2.</span> <span class="nav-text"> 1.2 概念摘要</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#121-一致性"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 1.2.1 一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#122-分布式中的网络模型"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 1.2.2 分布式中的网络模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#123-节点宕机"><span class="nav-number">1.2.3.</span> <span class="nav-text"> 1.2.3 节点宕机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#124-节点宕机恢复"><span class="nav-number">1.2.4.</span> <span class="nav-text"> 1.2.4 节点宕机恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#125-网络分化"><span class="nav-number">1.2.5.</span> <span class="nav-text"> 1.2.5 网络分化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#126-拜占庭将军问题"><span class="nav-number">1.2.6.</span> <span class="nav-text"> 1.2.6 拜占庭将军问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-一致性算法"><span class="nav-number">2.</span> <span class="nav-text"> 2. 一致性算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-问题提出"><span class="nav-number">2.1.</span> <span class="nav-text"> 2.1 问题提出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-问题分析"><span class="nav-number">2.2.</span> <span class="nav-text"> 2.2 问题分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#221-问题重述"><span class="nav-number">2.2.1.</span> <span class="nav-text"> 2.2.1 问题重述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#222-解决算法"><span class="nav-number">2.2.2.</span> <span class="nav-text"> 2.2.2 解决算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-算法分析"><span class="nav-number">2.3.</span> <span class="nav-text"> 2.3 算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#231-相关概念"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 2.3.1 相关概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#232-提案的选定"><span class="nav-number">2.3.2.</span> <span class="nav-text"> 2.3.2 提案的选定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2321-最简单的提案方法"><span class="nav-number">2.3.2.1.</span> <span class="nav-text"> 2.3.2.1 最简单的提案方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2322-多accpetor提案方法"><span class="nav-number">2.3.2.2.</span> <span class="nav-text"> 2.3.2.2 多Accpetor提案方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-获取被选定的提案值"><span class="nav-number">3.</span> <span class="nav-text"> 3. 获取被选定的提案值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-进展性"><span class="nav-number">4.</span> <span class="nav-text"> 4. 进展性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-flp-impossibility"><span class="nav-number">4.1.</span> <span class="nav-text"> 4.1 FLP impossibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-活锁"><span class="nav-number">4.2.</span> <span class="nav-text"> 4.1 活锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-leader算法"><span class="nav-number">4.3.</span> <span class="nav-text"> 4.2 Leader算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#421-概述"><span class="nav-number">4.3.1.</span> <span class="nav-text"> 4.2.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#422-multi-paxos"><span class="nav-number">4.3.2.</span> <span class="nav-text"> 4.2.2 Multi-Paxos</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4221-算法描述"><span class="nav-number">4.3.2.1.</span> <span class="nav-text"> 4.2.2.1 算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4222-幽灵复现缺陷"><span class="nav-number">4.3.2.2.</span> <span class="nav-text"> 4.2.2.2 幽灵复现缺陷</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-paxos实例"><span class="nav-number">5.</span> <span class="nav-text"> 5. Paxos实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-朴素paxos实例"><span class="nav-number">5.1.</span> <span class="nav-text"> 5.1 朴素Paxos实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#512-实例描述"><span class="nav-number">5.1.1.</span> <span class="nav-text"> 5.1.2 实例描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#513-宕机情况"><span class="nav-number">5.1.2.</span> <span class="nav-text"> 5.1.3 宕机情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-拓展"><span class="nav-number">6.</span> <span class="nav-text"> 6. 拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-raft协议"><span class="nav-number">6.1.</span> <span class="nav-text"> 6.1 Raft协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-zab协议"><span class="nav-number">6.2.</span> <span class="nav-text"> 6.2 Zab协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-quorom机制"><span class="nav-number">6.3.</span> <span class="nav-text"> 6.3 Quorom机制</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Song</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://yansongsongsong-github-io.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://yansongsongsong.github.io/paxos/';
          this.page.identifier = 'paxos/';
          this.page.title = 'paxos';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://yansongsongsong-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
